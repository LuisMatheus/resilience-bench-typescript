"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon_1 = require("sinon");
const TaskCancelledError_1 = require("../errors/TaskCancelledError");
const abort_1 = require("./abort");
const Event_1 = require("./Event");
describe('Event', () => {
    it('emits events', () => {
        const s1 = (0, sinon_1.stub)();
        const s2 = (0, sinon_1.stub)();
        const s3 = (0, sinon_1.stub)();
        const emitter = new Event_1.EventEmitter();
        const l1 = emitter.addListener(s1);
        emitter.emit(1);
        const l2 = emitter.addListener(s2);
        emitter.emit(2);
        const l3 = emitter.addListener(s3);
        emitter.emit(3);
        l1.dispose();
        emitter.emit(4);
        l2.dispose();
        emitter.emit(5);
        l3.dispose();
        emitter.emit(6);
        (0, chai_1.expect)(s1.args).to.deep.equal([[1], [2], [3]]);
        (0, chai_1.expect)(s2.args).to.deep.equal([[2], [3], [4]]);
        (0, chai_1.expect)(s3.args).to.deep.equal([[3], [4], [5]]);
    });
    it('memorizes event emissions', () => {
        const s1 = (0, sinon_1.stub)();
        const s2 = (0, sinon_1.stub)();
        const emitter = new Event_1.MemorizingEventEmitter();
        (0, chai_1.expect)(emitter.hasEmitted).to.be.false;
        emitter.addListener(s1);
        emitter.emit(42);
        (0, chai_1.expect)(emitter.hasEmitted).to.be.true;
        emitter.addListener(s2);
        (0, chai_1.expect)(s1).to.have.been.calledOnceWith(42);
        (0, chai_1.expect)(s2).to.have.been.calledOnceWith(42);
    });
    it('emits events once', () => {
        const s = (0, sinon_1.stub)();
        const emitter = new Event_1.EventEmitter();
        Event_1.Event.once(emitter.addListener, s);
        emitter.emit(42);
        emitter.emit(42);
        (0, chai_1.expect)(s).to.have.been.calledOnceWith(42);
    });
    it('emits events once with sync call', () => {
        const s = (0, sinon_1.stub)();
        const emitter = new Event_1.MemorizingEventEmitter();
        emitter.emit(42);
        Event_1.Event.once(emitter.addListener, s);
        emitter.emit(42);
        (0, chai_1.expect)(s).to.have.been.calledOnceWith(42);
    });
    it('converts to promise', async () => {
        const emitter = new Event_1.EventEmitter();
        const v = Event_1.Event.toPromise(emitter.addListener);
        emitter.emit(42);
        (0, chai_1.expect)(await v).to.equal(42);
        (0, chai_1.expect)(emitter.size).to.equal(0);
    });
    it('cancels conversion to promise', async () => {
        const emitter = new Event_1.EventEmitter();
        const cts = new AbortController();
        setTimeout(() => cts.abort(), 1);
        const v = Event_1.Event.toPromise(emitter.addListener, cts.signal);
        await (0, chai_1.expect)(v).to.eventually.be.rejectedWith(TaskCancelledError_1.TaskCancelledError);
        (0, chai_1.expect)(emitter.size).to.equal(0);
    });
    it('cancels conversion to promise sync', async () => {
        const emitter = new Event_1.EventEmitter();
        const v = Event_1.Event.toPromise(emitter.addListener, abort_1.abortedSignal);
        await (0, chai_1.expect)(v).to.eventually.be.rejectedWith(TaskCancelledError_1.TaskCancelledError);
        (0, chai_1.expect)(emitter.size).to.equal(0);
    });
});
//# sourceMappingURL=Event.test.js.map