"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon_1 = require("sinon");
const util_1 = require("util");
const Breaker_1 = require("./breaker/Breaker");
const CircuitBreakerPolicy_1 = require("./CircuitBreakerPolicy");
const abort_1 = require("./common/abort");
const Errors_1 = require("./errors/Errors");
const IsolatedCircuitError_1 = require("./errors/IsolatedCircuitError");
const Policy_1 = require("./Policy");
class MyException extends Error {
}
const delay = (0, util_1.promisify)(setTimeout);
describe('CircuitBreakerPolicy', () => {
    let p;
    let clock;
    let onBreak;
    let onReset;
    let onHalfOpen;
    beforeEach(() => {
        p = (0, Policy_1.circuitBreaker)((0, Policy_1.handleType)(MyException), {
            halfOpenAfter: 1000,
            breaker: new Breaker_1.ConsecutiveBreaker(2),
        });
        clock = (0, sinon_1.useFakeTimers)();
        onBreak = (0, sinon_1.stub)();
        onReset = (0, sinon_1.stub)();
        onHalfOpen = (0, sinon_1.stub)();
        p.onBreak(onBreak);
        p.onReset(onReset);
        p.onHalfOpen(onHalfOpen);
    });
    afterEach(() => {
        clock.restore();
    });
    const openBreaker = async () => {
        const s = (0, sinon_1.stub)().throws(new MyException());
        await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(MyException);
        await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(MyException);
    };
    it('allows calls when open', async () => {
        (0, chai_1.expect)(await p.execute(() => 42)).to.equal(42);
    });
    it('opens after failing calls', async () => {
        const s = (0, sinon_1.stub)().throws(new MyException());
        await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(MyException);
        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Closed);
        (0, chai_1.expect)(onBreak).not.called;
        await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(MyException);
        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Open);
        (0, chai_1.expect)(onBreak).called;
        await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(Errors_1.BrokenCircuitError);
        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Open);
        (0, chai_1.expect)(p.lastFailure.error).to.be.an.instanceOf(MyException);
        (0, chai_1.expect)(onBreak).calledOnce;
        (0, chai_1.expect)(s).calledTwice;
    });
    it('closes if the half open test succeeds', async () => {
        await openBreaker();
        clock.tick(1000);
        const result = p.execute((0, sinon_1.stub)().resolves(42));
        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.HalfOpen);
        (0, chai_1.expect)(onHalfOpen).calledOnce;
        (0, chai_1.expect)(await result).to.equal(42);
        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Closed);
        (0, chai_1.expect)(onReset).calledOnce;
    });
    it('dedupes half-open tests', async () => {
        await openBreaker();
        clock.tick(1000);
        // Two functinos, a and b. We execute with "a" first, and then make sure
        // it returns before "b" gets called.
        let aReturned = false;
        const a = async () => {
            await delay(10);
            aReturned = true;
            return 1;
        };
        const b = async () => {
            (0, chai_1.expect)(aReturned).to.be.true;
            return 2;
        };
        const todo = [
            (0, chai_1.expect)(p.execute(a)).to.eventually.equal(1),
            (0, chai_1.expect)(p.execute(b)).to.eventually.equal(2),
        ];
        clock.tick(10);
        await Promise.all(todo);
    });
    it('stops deduped half-open tests if the circuit reopens', async () => {
        await openBreaker();
        clock.tick(1000);
        // Two functinos, a and b. We execute with "a" first, and then make sure
        // it returns before "b" gets called.
        const a = async () => {
            await delay(10);
            throw new MyException();
        };
        const b = async () => {
            throw new Error('expected to not be called');
        };
        const todo = [
            (0, chai_1.expect)(p.execute(a)).to.be.rejectedWith(MyException),
            (0, chai_1.expect)(p.execute(b)).to.be.rejectedWith(Errors_1.BrokenCircuitError),
        ];
        clock.tick(10);
        await Promise.all(todo);
    });
    it('re-opens if the half open fails', async () => {
        await openBreaker();
        clock.tick(1000);
        const s = (0, sinon_1.stub)().throws(new MyException());
        await (0, chai_1.expect)(p.execute(s)).to.be.rejectedWith(MyException);
        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Open);
    });
    it('handles isolation correctly', async () => {
        const handle1 = p.isolate();
        (0, chai_1.expect)(onBreak).calledOnceWith({ isolated: true });
        const handle2 = p.isolate();
        (0, chai_1.expect)(onBreak).calledOnce;
        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Isolated);
        await (0, chai_1.expect)(p.execute(() => 42)).to.be.rejectedWith(IsolatedCircuitError_1.IsolatedCircuitError);
        handle1.dispose();
        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Isolated);
        (0, chai_1.expect)(onReset).not.called;
        handle2.dispose();
        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Closed);
        (0, chai_1.expect)(onReset).calledOnce;
        (0, chai_1.expect)(await p.execute(() => 42)).to.equal(42);
    });
    it('links parent cancellation token', async () => {
        const parent = new AbortController();
        await (0, Policy_1.circuitBreaker)(Policy_1.handleAll, {
            halfOpenAfter: 1000,
            breaker: new Breaker_1.ConsecutiveBreaker(3),
        }).execute(({ signal }) => {
            (0, chai_1.expect)(signal.aborted).to.be.false;
            parent.abort();
            (0, chai_1.expect)(signal.aborted).to.be.true;
        }, parent.signal);
    });
    it('aborts function execution if half open test succeeds', async () => {
        await openBreaker();
        clock.tick(1000);
        // half open test:
        p.execute((0, sinon_1.stub)().resolves(42));
        // queued timeout:
        await (0, chai_1.expect)(p.execute((0, sinon_1.stub)(), abort_1.abortedSignal)).to.be.rejectedWith(Errors_1.TaskCancelledError);
        (0, chai_1.expect)(p.state).to.equal(CircuitBreakerPolicy_1.CircuitState.Closed);
        (0, chai_1.expect)(onReset).calledOnce;
    });
});
//# sourceMappingURL=CircuitBreakerPolicy.test.js.map