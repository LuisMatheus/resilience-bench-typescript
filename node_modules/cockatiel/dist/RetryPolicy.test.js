"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon_1 = require("sinon");
const Backoff_1 = require("./backoff/Backoff");
const util_test_1 = require("./common/util.test");
const Policy_1 = require("./Policy");
(0, chai_1.use)(require('sinon-chai'));
(0, chai_1.use)(require('chai-as-promised'));
class MyErrorA extends Error {
    constructor() {
        super('Error A');
    }
}
class MyErrorB extends Error {
    constructor() {
        super('Error B');
    }
}
describe('RetryPolicy', () => {
    it('types return data correctly in all cases', async () => {
        const policy = (0, Policy_1.retry)(Policy_1.handleAll, { maxAttempts: 1 });
        const multiply = (n) => n * 2;
        multiply(await policy.execute(() => 42));
        multiply(await policy.execute(async () => 42));
    });
    describe('setting backoffs', () => {
        let s;
        let clock;
        let delays;
        beforeEach(() => {
            clock = (0, sinon_1.useFakeTimers)();
            delays = [];
            s = (0, sinon_1.stub)().throws(new MyErrorA());
        });
        afterEach(() => clock.restore());
        const makePolicy = (durations) => {
            const p = (0, Policy_1.retry)(Policy_1.handleAll, {
                maxAttempts: durations.length,
                backoff: new Backoff_1.IterableBackoff(durations),
            });
            p.onRetry(({ delay }) => {
                delays.push(delay);
                clock.tick(delay);
            });
            return p;
        };
        it('sets the retry delay', async () => {
            await (0, chai_1.expect)(makePolicy([50]).execute(s)).to.eventually.be.rejectedWith(MyErrorA);
            (0, chai_1.expect)(delays).to.deep.equal([50]);
            (0, chai_1.expect)(s).to.have.been.calledTwice;
        });
        it('sets the retry sequence', async () => {
            await (0, chai_1.expect)(makePolicy([10, 20, 20]).execute(s)).to.eventually.be.rejectedWith(MyErrorA);
            (0, chai_1.expect)(delays).to.deep.equal([10, 20, 20]);
            (0, chai_1.expect)(s).to.have.callCount(4);
        });
    });
    it('retries all errors', async () => {
        const s = (0, sinon_1.stub)().onFirstCall().throws(new MyErrorA()).onSecondCall().returns('ok');
        (0, chai_1.expect)(await (0, Policy_1.retry)(Policy_1.handleAll, {}).execute(s)).to.equal('ok');
        (0, chai_1.expect)(s).to.have.been.calledTwice;
    });
    it('filters error types', async () => {
        const s = (0, sinon_1.stub)().onFirstCall().throws(new MyErrorA()).onSecondCall().throws(new MyErrorB());
        await (0, chai_1.expect)((0, Policy_1.retry)((0, Policy_1.handleType)(MyErrorA), { maxAttempts: 5 }).execute(s)).to.eventually.be.rejectedWith(MyErrorB);
        (0, chai_1.expect)(s).to.have.been.calledTwice;
    });
    it('filters returns', async () => {
        const s = (0, sinon_1.stub)().onFirstCall().returns(1).onSecondCall().returns(2);
        (0, chai_1.expect)(await (0, Policy_1.retry)((0, Policy_1.handleWhenResult)(r => typeof r === 'number' && r < 2), { maxAttempts: 5 }).execute(s)).to.equal(2);
        (0, chai_1.expect)(s).to.have.been.calledTwice;
    });
    it('permits specifying exponential backoffs', async () => {
        const s = (0, sinon_1.stub)().returns(1);
        (0, chai_1.expect)(await (0, Policy_1.retry)((0, Policy_1.handleWhenResult)(r => typeof r === 'number'), { backoff: new Backoff_1.ExponentialBackoff({ generator: Backoff_1.noJitterGenerator }), maxAttempts: 2 }).execute(s)).to.equal(1);
        (0, chai_1.expect)(s).to.have.callCount(3);
    });
    it('bubbles returns when retry attempts exceeded', async () => {
        const s = (0, sinon_1.stub)().returns(1);
        (0, chai_1.expect)(await (0, Policy_1.retry)((0, Policy_1.handleWhenResult)(r => typeof r === 'number' && r < 2), { maxAttempts: 5 }).execute(s)).to.equal(1);
        (0, chai_1.expect)(s).to.have.callCount(6);
    });
    it('bubbles errors when retry attempts exceeded', async () => {
        const s = (0, sinon_1.stub)().throws(new MyErrorB());
        await (0, chai_1.expect)((0, Policy_1.retry)(Policy_1.handleAll, { maxAttempts: 5 }).execute(s)).to.eventually.be.rejectedWith(MyErrorB);
        (0, chai_1.expect)(s).to.have.callCount(6);
    });
    it('does not unref by default', async () => {
        const output = await (0, util_test_1.runInChild)(`
      c.retry(c.handleAll, { maxAttempts: 1 }).execute(() => {
        console.log('attempt');
        throw new Error('oh no!');
      });
    `);
        (0, chai_1.expect)(output).to.contain('oh no!');
    });
    it('unrefs as requested', async () => {
        const output = await (0, util_test_1.runInChild)(`
    c.retry(c.handleAll, { maxAttempts: 1 }).dangerouslyUnref().execute(() => {
      console.log('attempt');
      throw new Error('oh no!');
    });
    `);
        (0, chai_1.expect)(output).to.equal('attempt');
    });
    it('stops retries if cancellation is requested', async () => {
        const parent = new AbortController();
        const err = new Error();
        let calls = 0;
        await (0, chai_1.expect)((0, Policy_1.retry)(Policy_1.handleAll, { maxAttempts: 3 }).execute(({ signal }) => {
            calls++;
            (0, chai_1.expect)(signal.aborted).to.be.false;
            parent.abort();
            (0, chai_1.expect)(signal.aborted).to.be.true;
            throw err;
        }, parent.signal)).to.eventually.be.rejectedWith(err);
        (0, chai_1.expect)(calls).to.equal(1);
    });
    it('fires onGiveUp', async () => {
        const err = new MyErrorA();
        const s = (0, sinon_1.stub)().throws(err);
        const policy = (0, Policy_1.retry)((0, Policy_1.handleType)(MyErrorA), { maxAttempts: 5 });
        const onGiveUp = (0, sinon_1.stub)();
        policy.onGiveUp(onGiveUp);
        await (0, chai_1.expect)(policy.execute(s)).to.eventually.be.rejectedWith(MyErrorA);
        (0, chai_1.expect)(onGiveUp).to.have.been.calledWith({ error: err });
    });
});
//# sourceMappingURL=RetryPolicy.test.js.map