"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const util_1 = require("util");
const abort_1 = require("./common/abort");
const defer_1 = require("./common/defer");
const BulkheadRejectedError_1 = require("./errors/BulkheadRejectedError");
const Errors_1 = require("./errors/Errors");
const Policy_1 = require("./Policy");
const delay = (0, util_1.promisify)(setTimeout);
describe('Bulkhead', () => {
    let order = [];
    let fnIndex = 0;
    beforeEach(() => {
        order = [];
        fnIndex = 0;
    });
    const makeFn = () => {
        const index = fnIndex++;
        return async () => {
            order.push(`${index}: enter`);
            await delay(index * 2);
            order.push(`${index}: exit`);
            return index;
        };
    };
    const makeFns = (count) => {
        const out = [];
        for (let i = 0; i < count; i++) {
            out.push(makeFn());
        }
        return out;
    };
    it('rejects calls after limit is hit', async () => {
        const b = (0, Policy_1.bulkhead)(2);
        const funcs = makeFns(3);
        const output = funcs.map(fn => b.execute(fn));
        await Promise.all([
            (0, chai_1.expect)(output[0]).to.eventually.equal(0),
            (0, chai_1.expect)(output[1]).to.eventually.equal(1),
            (0, chai_1.expect)(output[2]).to.be.rejectedWith(BulkheadRejectedError_1.BulkheadRejectedError),
        ]);
        (0, chai_1.expect)(order).to.deep.equal(['0: enter', '1: enter', '0: exit', '1: exit']);
    });
    it('queues requests, and rejects after queue limit', async () => {
        const b = (0, Policy_1.bulkhead)(2, 2);
        const funcs = makeFns(5);
        const output = funcs.map(fn => b.execute(fn));
        await Promise.all([
            (0, chai_1.expect)(output[0]).to.eventually.equal(0),
            (0, chai_1.expect)(output[1]).to.eventually.equal(1),
            (0, chai_1.expect)(output[2]).to.eventually.equal(2),
            (0, chai_1.expect)(output[3]).to.eventually.equal(3),
            (0, chai_1.expect)(output[4]).to.be.rejectedWith(BulkheadRejectedError_1.BulkheadRejectedError),
        ]);
        (0, chai_1.expect)(order).to.deep.equal([
            '0: enter',
            '1: enter',
            '0: exit',
            '2: enter',
            '1: exit',
            '3: enter',
            '2: exit',
            '3: exit',
        ]);
    });
    it('maintains proper state', async () => {
        const b = (0, Policy_1.bulkhead)(2, 2);
        const defer1 = (0, defer_1.defer)();
        const defer2 = (0, defer_1.defer)();
        const defer3 = (0, defer_1.defer)();
        const defer4 = (0, defer_1.defer)();
        (0, chai_1.expect)(b.queueSlots).to.equal(2);
        (0, chai_1.expect)(b.executionSlots).to.equal(2);
        const out1 = b.execute(() => defer1.promise);
        (0, chai_1.expect)(b.queueSlots).to.equal(2);
        (0, chai_1.expect)(b.executionSlots).to.equal(1);
        const out2 = b.execute(() => defer2.promise);
        (0, chai_1.expect)(b.queueSlots).to.equal(2);
        (0, chai_1.expect)(b.executionSlots).to.equal(0);
        const out3 = b.execute(() => defer3.promise);
        (0, chai_1.expect)(b.queueSlots).to.equal(1);
        (0, chai_1.expect)(b.executionSlots).to.equal(0);
        const out4 = b.execute(() => defer4.promise);
        (0, chai_1.expect)(b.queueSlots).to.equal(0);
        (0, chai_1.expect)(b.executionSlots).to.equal(0);
        defer1.resolve(undefined);
        await out1;
        (0, chai_1.expect)(b.executionSlots).to.equal(0);
        (0, chai_1.expect)(b.queueSlots).to.equal(1);
        defer2.resolve(undefined);
        await out2;
        (0, chai_1.expect)(b.executionSlots).to.equal(0);
        (0, chai_1.expect)(b.queueSlots).to.equal(2);
        defer3.resolve(undefined);
        await out3;
        (0, chai_1.expect)(b.executionSlots).to.equal(1);
        (0, chai_1.expect)(b.queueSlots).to.equal(2);
        defer4.resolve(undefined);
        await out4;
        (0, chai_1.expect)(b.executionSlots).to.equal(2);
        (0, chai_1.expect)(b.queueSlots).to.equal(2);
    });
    it('links parent cancellation token', async () => {
        const b = (0, Policy_1.bulkhead)(1, Infinity);
        const todo = [];
        for (let i = 0; i < 3; i++) {
            const parent = new AbortController();
            todo.push(b.execute(async ({ signal }) => {
                await delay(1);
                (0, chai_1.expect)(signal.aborted).to.be.false;
                parent.abort();
                (0, chai_1.expect)(signal.aborted).to.be.true;
            }, parent.signal));
        }
        // initially cancelled
        todo.push((0, chai_1.expect)(b.execute(() => {
            throw new Error('expected not to call');
        }, abort_1.abortedSignal)).to.be.rejectedWith(Errors_1.TaskCancelledError));
        // cancelled by the time it gets executed
        const cancelledCts = new AbortController();
        setTimeout(() => cancelledCts.abort(), 2);
        todo.push((0, chai_1.expect)(b.execute(() => {
            throw new Error('expected not to call');
        }, cancelledCts.signal)).to.be.rejectedWith(Errors_1.TaskCancelledError));
        await Promise.all(todo);
    });
});
//# sourceMappingURL=BulkheadPolicy.test.js.map